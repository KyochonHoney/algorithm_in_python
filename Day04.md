# Day04. 
## 피보나치 수열 (Fibonacci Sequence)

## 피보나치 수열이란?

피보나치 수열은 첫째 항과 둘째 항이 특정 값(주로 0과 1)으로 시작하고, 그 다음 항부터는 바로 앞의 두 항을 더한 값으로 이루어지는 수열이에요. 자연, 예술, 심지어 금융 시장에서도 이 패턴을 찾아볼 수 있어서 "자연의 비밀 코드"라고도 불린답니다!

**수열의 예시**: `0, 1, 1, 2, 3, 5, 8, 13, 21, ...`

*   `F_0 = 0`
*   `F_1 = 1`
*   `F_2 = F_1 + F_0 = 1 + 0 = 1`
*   `F_3 = F_2 + F_1 = 1 + 1 = 2`
*   `F_4 = F_3 + F_2 = 2 + 1 = 3`
*   ...이렇게 계속 이어집니다.

**일반적인 점화식**: `F_n = F_{n-1} + F_{n-2}` (단, `n >= 2`)

---

## 1. 단순 재귀를 이용한 피보나치 수열 계산

피보나치 수열의 점화식을 그대로 코드로 옮긴 가장 직관적인 방법이에요.

```python
def fibo1(n):
    if n == 0: # 바닥 조건 1: F_0는 0
        return 0
    elif n == 1: # 바닥 조건 2: F_1는 1
        return 1
    # 재귀 호출: Fn = Fn-1 + Fn-2 점화식을 그대로 따라갑니다.
    return fibo1(n-1) + fibo1(n-2)

# 예시:
# print(fibo1(0)) # 0
# print(fibo1(1)) # 1
# print(fibo1(2)) # 1
# print(fibo1(3)) # 2
# print(fibo1(7)) # 13
```

*   **점화식**: `T(n) = T(n-1) + T(n-2) + C`
*   **수행 시간 (Time Complexity)**: 이 방식은 언뜻 보기엔 간단해 보이지만, **매우 비효율적**이에요. `fibo1(n)`을 계산할 때 `fibo1(n-1)`과 `fibo1(n-2)`를 각각 호출하는데, 이 과정에서 **동일한 계산이 반복적으로 이루어지는 "중복 계산"**이 엄청나게 발생합니다.
    *   예를 들어, `fibo1(5)`를 계산하려면 `fibo1(4)`와 `fibo1(3)`을 호출하고, `fibo1(4)`는 또 `fibo1(3)`과 `fibo1(2)`를 호출해요. 여기서 `fibo1(3)`이 두 번 호출되는 것을 볼 수 있죠? 이런 중복 호출이 기하급수적으로 늘어나기 때문에 수행 시간은 대략 `O(2^n)`에 가깝습니다. `n`이 조금만 커져도 계산 속도가 엄청나게 느려지는 문제가 있어요.

---

## 더 효율적인 피보나치 계산 방법 (참고)

위의 단순 재귀 방식의 비효율성(중복 계산)을 해결하기 위해 여러 가지 방법이 사용됩니다.

*   **메모이제이션 (Memoization) / 동적 계획법 (Dynamic Programming)**: 한번 계산한 값을 저장해두고, 필요할 때 다시 계산하는 대신 저장된 값을 재활용하는 방식이에요. 재귀 호출에 캐싱을 추가하거나, 반복문을 사용하여 아래에서부터 위로(바텀업) 계산해 나갑니다. 이 경우 `O(n)`의 시간 복잡도를 가집니다.
*   **반복문 (Iterative Method)**: 재귀 호출 없이 반복문을 사용하여 `F_0, F_1, F_2, ...` 순서대로 값을 계산하며 나아갑니다. 역시 `O(n)`의 시간 복잡도를 가집니다.
*   **행렬 거듭제곱 (Matrix Exponentiation)**: 아주 큰 `n` 값에 대해서는 행렬의 거듭제곱을 이용하여 `O(log n)`의 시간 복잡도로 피보나치 수를 계산할 수도 있습니다. 이 방법은 이진 지수화(Binary Exponentiation) 개념을 활용해요.